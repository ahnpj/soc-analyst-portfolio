Lab04 – Splunk Backdoor and Registry Investigation
===========================================

## Overview & Objective </br>

<details>

<summary><b>(Click to expand)</b></summary>

### Overview

In this lab, I wanted to practice approaching a host-compromise investigation in Splunk the same way I would in a real SOC: start with a broad view of the data, form a hypothesis, and then pivot through different log sources (Security, Sysmon/registry, and PowerShell logs) until I could tell a coherent story about what happened.

The dataset contained Windows event logs already ingested into Splunk. I approached it as if I had been handed an alert about suspicious activity on a Windows workstation and needed to answer a focused set of incident-response questions: Was a backdoor account created? How was it created? What changes were made on the host, and what follow-up activity did the attacker perform (for example, via PowerShell)?

Rather than blindly following a guided checklist, I tried to treat this like a mini-investigation: start with simple searches, inspect patterns, then refine my searches as I uncovered more context about the attacker’s behavior.

### Objective

The main objective of this lab was to investigate a suspected Windows host compromise using Splunk and to:

- Understand how many events were ingested into the main index and get a feel for the dataset size.
- Identify whether a backdoor user account was created and what username was used.
- Trace registry modifications tied to that backdoor account and locate the relevant registry path.
- Determine which legitimate user the adversary attempted to impersonate.
- Identify the command used to add the backdoor user from a remote computer.
- Measure how many login attempts were made using the backdoor account.
- Identify the infected host that executed suspicious PowerShell commands.
- Determine how many PowerShell events were generated by the malicious script.
- Extract the full URL contacted by the encoded PowerShell payload.

</details>

## Environment </br>

<details>

<summary><b>(Click to expand)</b></summary> </br>

After initializing the environment, I observed that it launched multiple virtual machines (VMs) that worked together throughout the investigation. The primary system I operated from was an AttackBox VM, which was assigned the internal IP `10.201.84.11` and `10.201.85.188`. This served as my main workstation for interacting with the environment, running queries, and accessing the logging interface.

I also identified that the Splunk server was hosted on a separate VM accessible at `10.201.83.141`. I entered this address in the browser to reach the Splunk web interface and begin reviewing the event data. The Windows VM responsible for generating the logs functioned as an isolated host in the background, forwarding its Windows event logs directly into the main index in Splunk. There was no requirement to access that VM directly.

I noted that all of these internal IP addresses were ephemeral. Whenever the environment restarted or refreshed, each VM received a new internal address. Because of this behavior, I made sure to verify the active IPs before starting any log analysis to ensure I was connecting to the correct systems.

<blockquote>
When I first accessed the Splunk interface and ran a basic search against the "main" index, I noticed that event data was already present. This is expected based on how the environment is structured. The Windows VM operating in the background is configured to automatically forward its event logs into Splunk as soon as the environment becomes active. Because of that, the ingestion pipeline is already running by the time I begin my analysis, and the main index contains a baseline of system activity, service events, and any simulated malicious behavior that occurred on the host. This pre-ingested data allowed me to start reviewing events immediately without having to manually trigger log generation or configure forwarding on my own.
</blockquote>

- **Platform:** Splunk Enterprise (web interface)
- **Data Source:** Pre-ingested Windows event logs (Security, Sysmon/registry, and PowerShell logging)
- **Index Used:** `main`
- **Role:** Acting as a SOC analyst / incident responder reviewing logs after a suspected compromise on a Windows endpoint.

</details>

## Scenario

<details>

<summary><b>(Click to expand)</b></summary> </br>

In this scenario, a Windows workstation is suspected of being compromised. The adversary appears to have:

1. Created a new local backdoor user account on one of the hosts.
2. Modified registry keys associated with that user to help maintain persistence.
3. Attempted to impersonate an existing, legitimate user account.
4. Used remote command execution to create the backdoor account.
5. Leveraged PowerShell with an encoded command to reach out to a remote web resource, possibly to download or execute additional payloads.

My job in this lab was to reconstruct what happened using Splunk searches and answer specific investigation questions using the logs.

</details>

---

## Step-by-Step Walkthrough

<details>

<summary><b>(Click to expand)</b></summary>

### Step 1 – Get a Feel for the Dataset (Event Count in `main`)

I started by checking how many events were ingested into the `main` index. This helps set expectations around performance and scope:

```spl
index=main
| stats count
```

This simple query returns a single row with a `count` field. That count tells me how many events I’m working with overall in this investigation. It also reassures me that events are actually present and that I’m querying the correct index.

<p align="left">
  <img src="images/lab12-splunk-backdoor-and-registry-investigation-01.png?raw=true&v=2" 
       style="border: 2px solid #444; border-radius: 6px;" 
       width="800"><br>
  <em>Figure 1</em>
</p>

Alternatively, I could simply run `index=main` and check the event count displayed next to the Events label in the Events tab.

<p align="left">
  <img src="images/lab12-splunk-backdoor-and-registry-investigation-02.png?raw=true&v=2" 
       style="border: 2px solid #444; border-radius: 6px;" 
       width="800"><br>
  <em>Figure 2</em>
</p>

### Step 2 – Look for Evidence of a New User (Backdoor Account)

Since I suspected that the attacker created a backdoor user, I looked for account-creation events and system commands related to `net user` or similar activity.

A simple starting point was to search for `net user` in command-line fields:

```spl
index=main ("net user" OR "net user /add")
```

<p align="left">
  <img src="images/lab12-splunk-backdoor-and-registry-investigation-03.png?raw=true&v=2" 
       style="border: 2px solid #444; border-radius: 6px;" 
       width="800"><br>
  <em>Figure 3</em>
</p>

**(Step 2-a)** 

From here, I examined the raw events and noticed a suspicious command that added a new local user. The command clearly indicated the username used for the backdoor account and included a password, which is a strong indicator of malicious activity when done outside of standard provisioning workflows.

This immediately returned several events from different logging sources. To understand the context of the execution, I focused on the raw event details rather than the extracted fields. Each event included a `CommandLine` field that contained the exact command executed on the host. Across all returned events, I consistently observed the following command: `net user /add Alberto paw0rd1`

The presence of this command in multiple logs indicated that the system recorded the action through several telemetry channels. Specifically, I saw entries with `Event ID 1`, `Event ID 4688`, and `Event ID 800`, each capturing the process execution from a different perspective:

- `Event ID 4688` (Windows Security – Process Creation): This event provided the most authoritative confirmation. It recorded the creation of a new process and included the full command line responsible for executing net.exe with the /add parameters. The inclusion of the username and password in clear text strongly suggested unauthorized activity.

- `Event ID 1` (Sysmon Process Creation): This log reinforced the security event by capturing the same command execution with additional metadata, such as the parent process and hash information. Although the hash was not critical for this step, the repeated appearance of the same command across multiple sources added confidence to the finding.

- `Event ID 800` (PowerShell or Script Execution Engine): While not directly tied to PowerShell script content, this event showed that the system also logged the activity at the script/engine level. It further confirmed that the system detected the process creation event through multiple behavioral channels.

I also noted recurring Process IDs (PIDs) associated with these events. Although the PIDs differed between events, which is expected when multiple logs capture the same action, they each referenced the same underlying execution of `net.exe`. The repeated appearance of this command across logs and process IDs indicated that the attacker executed a standard Windows utility to create a new local account.

Based on the combination of: the `/add` flag, the presence of a `cleartext password`, and the fact that no legitimate provisioning workflow should involve manual net user commands, I identified this as a backdoor account creation performed by the adversary. The repeated corroboration across multiple event channels provided a reliable chain of evidence confirming the malicious activity.

**(Step 2-b)** 

In addition to command-line logs, I could also pivot into Windows Security events (for example, account creation events such as Event ID 4720) using a search like:

```spl
index=main EventID=4720
```

<p align="left">
  <img src="images/lab12-splunk-backdoor-and-registry-investigation-04.png?raw=true&v=2" 
       style="border: 2px solid #444; border-radius: 6px;" 
       width="800"><br>
  <em>Figure 4</em>
</p>

Reviewing those events confirmed the new user account and helped answer the question of which username was introduced as the backdoor. On one of the infected hosts, the adversary was successful in creating a backdoor user, `A1berto`.

### Step 3 – Tracing Registry Modifications Connected to the Backdoor User

After confirming that a suspicious backdoor user had been created, I wanted to know if anything on the system had changed to support persistence. Whenever a new local account is introduced during an intrusion, registry modifications are one of the first places I check. They often reflect when Windows records a new profile or when attackers intentionally tamper with account‐related keys.

Because I already knew the username the attacker created (`A1berto`), I began looking for registry events tied to that name. I focused on `Registry Event ID 12` (object creation or deletion) since that tends to show new keys being written. A targeted search helped surface the relevant events:

```
index=main Hostname="Micheal.Beaven" EventID=12 A1berto
```

<p align="left">
  <img src="images/lab12-splunk-backdoor-and-registry-investigation-05.png?raw=true&v=2" 
       style="border: 2px solid #444; border-radius: 6px;" 
       width="800"><br>
  <em>Figure 5</em>
</p>

<blockquote>
I filtered by the hostname because the backdoor account was created on that specific machine. Using the hostname kept the registry search focused on the same system involved in the compromise and prevented unrelated registry events from other hosts from cluttering the results. This made it easier to spot the exact registry key tied to the newly created user.
</blockquote>

As I sifted through the event details, the registry path stood out immediately. Windows keeps local user profile metadata under the SAM hive, and I found an entry specifically referencing the backdoor username:

`HKLM\SAM\SAM\Domains\Account\Users\Names\A1berto`

Seeing this registry key confirmed that Windows had registered the newly created account. The timing aligned cleanly with the earlier command-line execution, reinforcing that this wasn’t accidental activity the attacker had successfully implanted a persistent local account onto the system.

The `TargetObject` field in registry events represents the exact registry key or value that was created, modified, or deleted. In other words, Splunk uses this field to store the full registry path involved in the event. So when I was looking for the registry key tied to the backdoor account, `TargetObject` was the field that actually revealed:

Without `TargetObject`, the registry event would tell me that something changed, but not which key was impacted. That’s why TargetObject mattered, it’s the field that contains the full registry path, which is exactly what I needed to identify the persistence artifact linked to the attacker’s backdoor user.

---

### Step 4 – Figuring Out Which Legitimate User the Attacker Tried to Mimic

Now that I understood how the new user was introduced, I wanted to understand *who* the attacker was trying to blend in with. Attackers rarely operate solely under their new account; they often attempt to impersonate someone else to disguise their lateral movement.

I did a broad sweep across all logs to see what usernames appeared around the same time:

```
index=main
```

As I reviewed the `User` field patterns in the field sidebar, one thing immediately stood out: the legitimate username **Alberto**. The attacker created a backdoor user named **A1berto**. Same name, single character swapped.

While not overly sophisticated, this type of username confusion is common in real-world compromises. It can easily trick an analyst who isn’t paying close attention, especially when sorting or grouping events alphabetically. This small detail revealed the adversary’s intent to masquerade as the legitimate user while performing unauthorized actions.

<p align="left">
  <img src="images/lab12-splunk-backdoor-and-registry-investigation-06.png?raw=true&v=2" 
       style="border: 2px solid #444; border-radius: 6px;" 
       width="800"><br>
  <em>Figure 6</em>
</p>

---

### Step 5 – Understanding How the Backdoor User Was Created Remotely

Next, I wanted to understand *how* the attacker executed the account creation. The earlier logs suggested remote manipulation rather than a local command, so I pivoted toward process-creation events that might reveal the exact tooling used.

Since `Event ID 4688` captures process creation, I filtered on that:

```
index=main EventID=4688
```

Within the returned events, one command-line entry (`CommandLine` field) tied everything together. The attacker executed a WMIC command from a remote host to run `net user /add` on the target machine:

```
C:\windows\System32\Wbem\WMIC.exe /node:WORKSTATION6 process call create "net user /add A1berto paw0rd1"
```

This confirmed the attacker wasn’t physically or interactively on the host. Instead, they used `Wmic` (Windows Management Instrumentation Command-line), which is a built-in Windows command that lets administrators run system-level operations locally or remotely. It’s normally used for things like querying system info, starting processes, managing services, or controlling remote machines, all without needing RDP or interactive logins. It doesn’t require additional software, it blends in with legitimate admin activity, and it supports remote command execution.

it immediately told me two things:

- The attacker was operating remotely, so they weren’t on the compromised host directly.
- They were abusing a legitimate admin tool to create the backdoor user in a way that avoids detection and doesn’t rely on external malware.

<p align="left">
  <img src="images/lab12-splunk-backdoor-and-registry-investigation-07.png?raw=true&v=2" 
       style="border: 2px solid #444; border-radius: 6px;" 
       width="800"><br>
  <em>Figure 7</em>
</p>

---

### Step 6 – Checking Whether the Backdoor Account Was Ever Used

After confirming the account was created remotely, I wanted to see whether the attacker attempted to authenticate using this new identity. 

I searched for any authentication or logon events referencing the username:

```
index=main A1berto
```

<p align="left">
  <img src="images/lab12-splunk-backdoor-and-registry-investigation-08.png?raw=true&v=2" 
       style="border: 2px solid #444; border-radius: 6px;" 
       width="800"><br>
  <em>Figure 8</em>
</p>

Once I confirmed how the backdoor account was created, I wanted to see whether the attacker actually logged in with it. I started by filtering for events tied to the username and then looked at the `Category` field to get a quick sense of what types of actions were associated with it. If the account had been used interactively, I would expect to see something tied to `Logon/Logoff` or `Account Management`. Instead, nothing in the `Category` field indicated any authentication activity.

<p align="left">
  <img src="images/lab12-splunk-backdoor-and-registry-investigation-09.png?raw=true&v=2" 
       style="border: 2px solid #444; border-radius: 6px;" 
       width="800"><br>
  <em>Figure 9</em>
</p>

To double-check, I looked at the `EventID` field as well, since Windows uses specific IDs for login attempts, `4624` for successful logons and `4625` for failed ones. Neither of these appeared for the backdoor username. The absence of these event IDs confirmed what the `Category` field was already hinting that the new account was created successfully, but it was never used for any actual login attempt during the timeframe captured in the dataset.

<p align="left">
  <img src="images/lab12-splunk-backdoor-and-registry-investigation-10.png?raw=true&v=2" 
       style="border: 2px solid #444; border-radius: 6px;" 
       width="800"><br>
  <em>Figure 10</em>
</p>

This told me the account was likely staged for future access or intended as a fallback rather than used immediately.

---

### Step 7 – Identifying Which Host Ran the Suspicious PowerShell

Next, I pivoted into PowerShell activity to understand how the attacker continued interacting with the environment. Attackers frequently use encoded PowerShell commands to download payloads or run scripts in memory.

To identify the affected host, I searched for PowerShell-related logs:

```
index=main PowerShell
```

<p align="left">
  <img src="images/lab12-splunk-backdoor-and-registry-investigation-11.png?raw=true&v=2" 
       style="border: 2px solid #444; border-radius: 6px;" 
       width="800"><br>
  <em>Figure 11</em>
</p>

I checked the `Hostname` field and saw that only a single hostname consistently appeared in the results: **James.browne**.

<p align="left">
  <img src="images/lab12-splunk-backdoor-and-registry-investigation-12.png?raw=true&v=2" 
       style="border: 2px solid #444; border-radius: 6px;" 
       width="800"><br>
  <em>Figure 12</em>
</p>

This made it clear that the malicious PowerShell activity originated entirely from that machine. That host instantly became the centerpiece of the remaining analysis.

---

### Step 8 – Measuring the Extent of Malicious PowerShell Execution

Once I identified the infected host, I wanted to measure how noisy the malicious PowerShell execution was. I focused on `Event ID 4103`, which logs PowerShell engine activity:

```
index=main EventID=4103
```

<p align="left">
  <img src="images/lab12-splunk-backdoor-and-registry-investigation-13.png?raw=true&v=2" 
       style="border: 2px solid #444; border-radius: 6px;" 
       width="800"><br>
  <em>Figure 13</em>
</p>

Splunk returned **79 events**, all tied to the malicious encoded payload activity. This quantity suggested either repeated execution or a script that generated multiple engine events as it unpacked or processed its instructions.

Understanding this volume helped me contextualize how active the malicious script was and how visible it would be to defenders with adequate logging enabled.

---

### Step 9 – Decoding the Encoded PowerShell Payload and Extracting the URL

After identifying `James.browne` as the host running suspicious PowerShell, I wanted to know exactly where the script was calling out to. I focused on PowerShell logging for that host and looked at events from the PowerShell channel (such as EventID 800 – pipeline execution details). 

```
index=main PowerShell
```

<p align="left">
  <img src="images/lab12-splunk-backdoor-and-registry-investigation-14.png?raw=true&v=2" 
       style="border: 2px solid #444; border-radius: 6px;" 
       width="800"><br>
  <em>Figure 14</em>
</p>

When I pulled up the PowerShell events for `James.browne`, one detail immediately caught my eye: the `HostApplication` field contained a very long, uninterrupted block of characters right after the `-enc` flag. PowerShell only uses `-enc` when it’s executing a Base64-encoded script, so seeing a huge encoded blob like that is a strong indicator that the attacker was hiding the real command. 

These events showed the pipeline context and the parameter values passed into the script. In the Details section, I noticed several paths being used as input, including `/admin/get.php`, `/news.php`, and `/login/process.php`.

To understand what the attacker’s PowerShell command was actually doing, I took the long Base64 string I copied earlier from the `-enc` portion of the PowerShell event and pasted it into CyberChef. 

<blockquote>
CyberChef is useful here because it lets me quickly decode encoded payloads without running anything on the host itself. Since attackers often hide their real commands inside Base64, this step lets me peel back the obfuscation safely.
</blockquote>

For my recipe, I used “From Base64” followed by “Decode text (UTF-16LE)”. PowerShell typically encodes its commands in UTF-16LE before Base64 encoding them, so this decoding chain matches the way PowerShell constructs its encoded payloads. Using anything else would result in unreadable output. Once the first layer decoded, I noticed something immediately: the output still wasn’t the final script. Instead, buried inside the decoded text was another large Base64 block (the part I highlighted in yellow). Attackers do this on purpose, double-encoding adds another layer of obfuscation and makes detection more difficult.

During decoding, I noticed that the first layer of Base64 revealed several possible PHP file paths that the script could use (`/admin/get.php`, `/news.php`, `/login/process.php`). After decoding the second Base64 block, the script resolved to a specific one, `news.php`. So the “different php file” simply refered to the fact that the second layer revealed the actual file the attacker’s payload contacted.

<p align="left">
  <img src="images/lab12-splunk-backdoor-and-registry-investigation-15.png?raw=true&v=2" 
       style="border: 2px solid #444; border-radius: 6px;" 
       width="800"><br>
  <em>Figure 15</em>
</p>

So I copied that second Base64 blob, cleared the input, and ran it through the same recipe again. This finally produced the fully decoded PowerShell payload, including the outbound web request the infected host was making.

<p align="left">
  <img src="images/lab12-splunk-backdoor-and-registry-investigation-16.png?raw=true&v=2" 
       style="border: 2px solid #444; border-radius: 6px;" 
       width="800"><br>
  <em>Figure 16</em>
</p>

This decode immediately revealed the attacker’s callback destination, a plain-text URL pointing to `http://10.10.10.5`. Since earlier decoded script fragments already referenced specific PHP endpoints (such as `/admin/get.php`, `/news.php`, and `/login/process.php`), this step confirmed the actual host the infected machine was attempting to reach. 

During the first layer of decoding, the PowerShell script showed several possible PHP file paths (`/admin/get.php`, `/news.php`, `/login/process.php`). These appeared as part of the script’s internal logic, not as final choices. Once I decoded the second Base64 layer, the actual payload that got executed, and the script clearly resolved to a single endpoint: `news.php`.

This indicates that `news.php` is the specific file the attacker’s script chose to contact during execution, even though multiple paths existed in the earlier decoding stage.

Once I fully decoded the attacker’s PowerShell script, I finally got the real URL it was trying to reach: `http://10.10.10.5/news.php`

Before adding this to my notes, I wanted to make it safe to share. If I put a live malicious URL in a report, someone could accidentally click it. To avoid that, I used CyberChef’s Defang URL option. Defanging here to change the URL so it can’t be clicked or used directly, while still showing what it is. This way, the URL is harmless in documentation, but still readable if someone needs to re-create it for analysis later.
 After running it through the defang recipe (escaping dots and the “http” part), the output became:

`hxxp[://]10[.]10[.]10[.]5/news[.]php`

This confirmed the final destination of the malicious PowerShell command.

<p align="left">
  <img src="images/lab12-splunk-backdoor-and-registry-investigation-17.png?raw=true&v=2" 
       style="border: 2px solid #444; border-radius: 6px;" 
       width="800"><br>
  <em>Figure 17</em>
</p>

</details>


---

## Findings and Analysis </br>

<details>

<summary><b>(Click to expand)</b></summary> </br>

- A new local user account was created on one of the Windows hosts, acting as a backdoor account.
- Registry keys tied to local accounts were modified to reflect the presence of this backdoor user, indicating that the attacker was making persistent changes on the host.
- Logs showed that the attacker was attempting to impersonate a legitimate user, which helped explain the choice of username and the behavioral pattern around logon events.
- The backdoor account was created remotely using a WMIC command that executed `net user /add` on the target host. This demonstrates the use of “living off the land” binaries for remote administration and lateral movement.
- Login attempts from the backdoor user were identifiable in the Security logs, making it possible to count and describe how often the attacker tried to authenticate with that account.
- One host clearly stood out as the infected endpoint based on its suspicious PowerShell history.
- PowerShell logging, which is sometimes disabled in real environments, proved extremely valuable here. It allowed me to count the number of malicious PowerShell events and reconstruct the encoded command.
- Decoding the PowerShell payload exposed a full URL contacted by the script, which would be critical for further threat intelligence (for example, blocking the domain/IP, checking reputation, or pivoting in other tools).

Overall, the logs painted a classic small-scale intrusion story: account creation, registry modification, impersonation attempts, remote administration abuse, and a scripted outbound web request.

</details>

## What I Learned </br>

<details>

<summary><b>(Click to expand)</b></summary> </br>

- **Event volume context matters.** Starting with a simple `stats count` over the index gave me a quick sense of scale and reassured me that my searches were running over the correct dataset.
- **Backdoor accounts leave multiple traces.** Between Security events, command-line logs, and registry entries, a single malicious user account shows up in several places. Knowing how to pivot between them is key.
- **Registry artifacts are powerful for persistence analysis.** Even when you don’t know exactly what to look for at first, combining keyword searches with registry fields makes it possible to spot suspicious changes tied to user accounts.
- **Impersonation is often visible in logon patterns.** By correlating logon events with the surrounding activity window, it becomes much easier to tell which legitimate user the attacker was trying to mimic.
- **Remote execution stands out when you look at WMIC and similar tools.** Searching for utilities like `wmic`, `psexec`, or `sc` can quickly surface commands that attackers use for lateral movement and remote changes.
- **PowerShell logging is invaluable.** When it’s enabled, it turns what would otherwise be opaque encoded commands into something you can fully reconstruct. This lab reinforced how important it is to enable and retain detailed PowerShell logs in real environments.
- **Decoding payloads is worth the extra step.** Taking the time to decode the PowerShell payload wasn’t just a neat trick—it gave me the exact URL being contacted, which is critical for incident response, threat hunting, and building detections.

This lab was a good reminder that Splunk isn’t just about writing searches; it’s about telling a narrative. By the end, I could clearly explain what the attacker did, how they did it, and which artifacts would be useful for detections and future hunts.

</details>

