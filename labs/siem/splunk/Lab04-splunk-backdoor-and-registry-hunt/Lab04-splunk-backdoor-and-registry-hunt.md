Lab04 – Splunk Backdoor and Registry Hunt
===========================================

## Overview & Objective </br>

<details>

<summary><b>(Click to expand)</b></summary>

### Overview

In this lab, I wanted to practice approaching a host-compromise investigation in Splunk the same way I would in a real SOC: start with a broad view of the data, form a hypothesis, and then pivot through different log sources (Security, Sysmon/registry, and PowerShell logs) until I could tell a coherent story about what happened.

The dataset contained Windows event logs already ingested into Splunk. I approached it as if I had been handed an alert about suspicious activity on a Windows workstation and needed to answer a focused set of incident-response questions: Was a backdoor account created? How was it created? What changes were made on the host, and what follow-up activity did the attacker perform (for example, via PowerShell)?

Rather than blindly following a guided checklist, I tried to treat this like a mini-investigation: start with simple searches, inspect patterns, then refine my searches as I uncovered more context about the attacker’s behavior.

### Objective

The main objective of this lab was to investigate a suspected Windows host compromise using Splunk and to:

- Understand how many events were ingested into the main index and get a feel for the dataset size.
- Identify whether a backdoor user account was created and what username was used.
- Trace registry modifications tied to that backdoor account and locate the relevant registry path.
- Determine which legitimate user the adversary attempted to impersonate.
- Identify the command used to add the backdoor user from a remote computer.
- Measure how many login attempts were made using the backdoor account.
- Identify the infected host that executed suspicious PowerShell commands.
- Determine how many PowerShell events were generated by the malicious script.
- Extract the full URL contacted by the encoded PowerShell payload.

</details>

## Environment </br>

<details>

<summary><b>(Click to expand)</b></summary> </br>

- **Platform:** Splunk Enterprise (web interface)
- **Data Source:** Pre-ingested Windows event logs (Security, Sysmon/registry, and PowerShell logging)
- **Index Used:** `main`
- **Role:** Acting as a SOC analyst / incident responder reviewing logs after a suspected compromise on a Windows endpoint.

</details>

## Scenario

<details>

<summary><b>(Click to expand)</b></summary> </br>

In this scenario, a Windows workstation is suspected of being compromised. The adversary appears to have:

1. Created a new local backdoor user account on one of the hosts.
2. Modified registry keys associated with that user to help maintain persistence.
3. Attempted to impersonate an existing, legitimate user account.
4. Used remote command execution to create the backdoor account.
5. Leveraged PowerShell with an encoded command to reach out to a remote web resource, possibly to download or execute additional payloads.

My job in this lab was to reconstruct what happened using Splunk searches and answer specific investigation questions using the logs.

</details>

---

## Step-by-Step Walkthrough

<details>

<summary><b>(Click to expand)</b></summary>

### Step 1 – Get a Feel for the Dataset (Event Count in `main`)

I started by checking how many events were ingested into the `main` index. This helps set expectations around performance and scope:

```spl
index=main
| stats count
```

This simple query returns a single row with a `count` field. That count tells me how many events I’m working with overall in this investigation. It also reassures me that events are actually present and that I’m querying the correct index.

### Step 2 – Look for Evidence of a New User (Backdoor Account)

Since I suspected that the attacker created a backdoor user, I looked for account-creation events and system commands related to `net user` or similar activity.

A simple starting point was to search for `net user` in command-line fields:

```spl
index=main ("net user" OR "net user /add")
```

From here, I examined the raw events and noticed a suspicious command that added a new local user. The command clearly indicated the username used for the backdoor account and included a password, which is a strong indicator of malicious activity when done outside of standard provisioning workflows.

In addition to command-line logs, I could also pivot into Windows Security events (for example, account creation events such as Event ID 4720) using a search like:

```spl
index=main EventCode=4720
```

Reviewing those events confirmed the new user account and helped answer the question of which username was introduced as the backdoor.

### Step 3 – Trace Registry Modifications for the Backdoor User

Knowing the backdoor username, the next step was to see whether any registry keys were modified in connection with that account. Registry-based persistence is common, especially when attackers want their changes to survive reboots.

I searched for registry-related events that mentioned the backdoor username, or for events where the registry path contained references to user accounts:

```spl
index=main (Registry OR "regedit" OR "HKLM") backdoor_username_here
```

Depending on how the logs were normalized, there might be specific fields such as `Registry_Key_Path` or `TargetObject`. I focused on those fields to extract the full registry path.

By reviewing the returned events, I identified a registry key path under `HKLM` that referenced the new backdoor account. This registry path was tied to local user account data and clearly showed that the system had been modified to record or support the backdoor user.

This answered the question about the full path of the registry key associated with the newly created account.

### Step 4 – Identify the Legitimate User Being Impersonated

The next question was: which legitimate user did the attacker attempt to impersonate? This usually shows up in two places:

- The account that appears in logon attempts.
- The account name appearing in context with suspicious commands.

I searched for logon events related to the suspicious activity window. For example:

```spl
index=main EventCode=4624 OR EventCode=4625
```

From there, I reviewed the `Account_Name` or equivalent field and looked at which accounts were repeatedly involved around the same time frame as the backdoor-related events. The pattern made it clear which user the attacker was trying to mimic — the legitimate account appeared alongside unauthorized activity, while the newly created account seemed to be used as a backdoor alternative.

### Step 5 – Find the Command Used to Add the Backdoor User Remotely

To understand the attacker’s tooling, I wanted to know exactly how they created the backdoor account from a remote host. I focused on commands that combined remote execution utilities (for example, WMIC) with user-management operations.

I used a search like:

```spl
index=main ("wmic" OR "WMIC.exe") ("net user" OR "/add")
```

By reviewing the `CommandLine` field in the resulting events, I found a full command that:

- Used WMIC to target a remote workstation.
- Invoked `process call create` to run a `net user /add` command on that remote system.
- Specified the new username and password.

This command provided clear evidence of how the attacker was able to add the backdoor user from another machine, which is very relevant when documenting lateral movement or remote administration abuse.

### Step 6 – Count Login Attempts from the Backdoor User

To measure how “active” the backdoor account was during this dataset, I needed to see how many times it was used for logon attempts. I filtered Windows Security events for the new username:

```spl
index=main (EventCode=4624 OR EventCode=4625) Account_Name=backdoor_username_here
| stats count
```

This query returns how many times the backdoor account appeared in successful or failed logon events. Even a small number of attempts can still be significant, but understanding the count helps describe the scope of the compromise in a report.

### Step 7 – Identify the Infected Host with Suspicious PowerShell

Next, I wanted to locate the host where malicious PowerShell commands were executed. Many investigations pivot to PowerShell because attackers often use it for fileless or “living off the land” activity.

I started with a broad PowerShell search:

```spl
index=main ("powershell.exe" OR "PowerShell" OR "EncodedCommand")
```

From there, I looked at fields such as `host`, `ComputerName`, or `Hostname` to see which system(s) were generating suspicious PowerShell activity. One host clearly stood out with commands that didn’t look like normal admin or maintenance work, which allowed me to identify the primary infected machine responsible for executing the malicious PowerShell.

### Step 8 – Count the Malicious PowerShell Events

To better quantify the activity, I counted the number of PowerShell events tied to the malicious behavior. This could involve filtering on certain command-line patterns, encoded commands, or specific event IDs associated with PowerShell logging (for example, PowerShell Operational logs).

For example:

```spl
index=main ("powershell.exe" OR "EncodedCommand") host=infected_host_here
| stats count
```

The result showed how many events belonged to that particular malicious execution sequence. This is useful for the final report when describing how “noisy” or “quiet” the attacker was in the logs.

### Step 9 – Extract the Full URL from the Encoded PowerShell Command

Finally, I wanted to know exactly where the encoded PowerShell script was calling out to. Many PowerShell payloads use Base64-encoded commands with `-EncodedCommand` to hide their behavior at a quick glance.

I focused on events where the command line contained `-EncodedCommand`:

```spl
index=main "EncodedCommand" host=infected_host_here
```

After identifying the relevant event, I copied the encoded blob from the command line and decoded it outside of Splunk (for example, using a simple Base64 decode in a separate tool or script).

The decoded PowerShell revealed a `Invoke-WebRequest` (or similar) call that contacted a specific URL. This URL is the one I documented as the final answer, since it shows the remote resource the payload was trying to reach — likely a staging server, C2 endpoint, or malware hosting page.

</details>

---

## Findings and Analysis </br>

<details>

<summary><b>(Click to expand)</b></summary> </br>

- A new local user account was created on one of the Windows hosts, acting as a backdoor account.
- Registry keys tied to local accounts were modified to reflect the presence of this backdoor user, indicating that the attacker was making persistent changes on the host.
- Logs showed that the attacker was attempting to impersonate a legitimate user, which helped explain the choice of username and the behavioral pattern around logon events.
- The backdoor account was created remotely using a WMIC command that executed `net user /add` on the target host. This demonstrates the use of “living off the land” binaries for remote administration and lateral movement.
- Login attempts from the backdoor user were identifiable in the Security logs, making it possible to count and describe how often the attacker tried to authenticate with that account.
- One host clearly stood out as the infected endpoint based on its suspicious PowerShell history.
- PowerShell logging, which is sometimes disabled in real environments, proved extremely valuable here. It allowed me to count the number of malicious PowerShell events and reconstruct the encoded command.
- Decoding the PowerShell payload exposed a full URL contacted by the script, which would be critical for further threat intelligence (for example, blocking the domain/IP, checking reputation, or pivoting in other tools).

Overall, the logs painted a classic small-scale intrusion story: account creation, registry modification, impersonation attempts, remote administration abuse, and a scripted outbound web request.

</details>

## What I Learned </br>

<details>

<summary><b>(Click to expand)</b></summary> </br>

- **Event volume context matters.** Starting with a simple `stats count` over the index gave me a quick sense of scale and reassured me that my searches were running over the correct dataset.
- **Backdoor accounts leave multiple traces.** Between Security events, command-line logs, and registry entries, a single malicious user account shows up in several places. Knowing how to pivot between them is key.
- **Registry artifacts are powerful for persistence analysis.** Even when you don’t know exactly what to look for at first, combining keyword searches with registry fields makes it possible to spot suspicious changes tied to user accounts.
- **Impersonation is often visible in logon patterns.** By correlating logon events with the surrounding activity window, it becomes much easier to tell which legitimate user the attacker was trying to mimic.
- **Remote execution stands out when you look at WMIC and similar tools.** Searching for utilities like `wmic`, `psexec`, or `sc` can quickly surface commands that attackers use for lateral movement and remote changes.
- **PowerShell logging is invaluable.** When it’s enabled, it turns what would otherwise be opaque encoded commands into something you can fully reconstruct. This lab reinforced how important it is to enable and retain detailed PowerShell logs in real environments.
- **Decoding payloads is worth the extra step.** Taking the time to decode the PowerShell payload wasn’t just a neat trick—it gave me the exact URL being contacted, which is critical for incident response, threat hunting, and building detections.

This lab was a good reminder that Splunk isn’t just about writing searches; it’s about telling a narrative. By the end, I could clearly explain what the attacker did, how they did it, and which artifacts would be useful for detections and future hunts.

</details>
